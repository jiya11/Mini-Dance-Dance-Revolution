//LAST UPDATED NOV 19 3:37 AM

//Functioning one person player so far
module vga_demo(CLOCK_50, SW, KEY, VGA_R, VGA_G, VGA_B, VGA_HS, VGA_VS, VGA_BLANK_N, VGA_SYNC_N, VGA_CLK, HEX3, HEX2, HEX1, HEX0,  LEDR);
	input CLOCK_50;	
	input [9:0] SW; //SW[9] for reset
	input [3:0] KEY; //directional inputs
	output [6:0] HEX3, HEX2, HEX1, HEX0;
	output [7:0] VGA_R;
	output [7:0] VGA_G;
	output [7:0] VGA_B;
	output VGA_HS, VGA_VS, VGA_BLANK_N, VGA_SYNC_N, VGA_CLK;
	output [9:0] LEDR; //showing debounced outputs
	
	wire [3:0] debounced_keys;
	wire perfect_hit;
	
	// Instantiate input processing module
   input_processing input_proc (
		.CLOCK_50(CLOCK_50),
      .KEY(KEY),
      .SW(SW),
      .LEDR(LEDR),
		.a_out(debounced_keys)
   );
	
	// Instantiate score tracking module
	score_tracker tracker_inst (
        .CLOCK_50(CLOCK_50),   // System clock
        .reset(SW[9]),         // Reset signal (connected to a KEY)
        .key_press(debounced_keys),       // Push button inputs (KEY)
		  .perfect_hit(perfect_hit),
        .HEX0(HEX0),           // Output to HEX displays
        .HEX1(HEX1),
        .HEX2(HEX2),
        .HEX3(HEX3)
    );
	 
	 //Instantiate arrow module
	 arrow_game game_inst(
		.CLOCK_50(CLOCK_50),
      .reset(SW[9]),
      .key_press(debounced_keys),
      .VGA_R(VGA_R),
      .VGA_G(VGA_G),
      .VGA_B(VGA_B),
      .VGA_HS(VGA_HS),
      .VGA_VS(VGA_VS),
      .VGA_BLANK_N(VGA_BLANK_N),
      .VGA_SYNC_N(VGA_SYNC_N),
      .VGA_CLK(VGA_CLK),
      .perfect_hit(perfect_hit)
    );
	 
endmodule

//Input Processing Module
module input_processing(
	input CLOCK_50,		// DE1-SoC 50MHz clock
   input [3:0] KEY,		// KEY[3:0] for directional inputs (active low)
								// KEY[3] = up, KEY[2] = down, KEY[1] = left, KEY[0] = right
   input [9:0] SW,		// SW[9] used for reset
   output [9:0] LEDR,		// LEDR[3:0] shows debounced outputs
	output reg [3:0] a_out	//Debounced outputs for external use
);
	
	// Parameters
   parameter DB = 1_000_000;  // 20ms at 50MHz (50M * 0.02)
   
   // Internal signals
   wire [3:0] a_in;          // Inputs after active-low conversion
   reg [3:0] a_led;          // LED outputs
   wire reset;               // Reset signal
    
   // Convert active-low KEY inputs to active-high
   assign a_in = ~KEY[3:0];
   
   // Use SW[9] for reset
   assign reset = SW[9];
    
   // Connect internal LED signals to actual LEDs
   assign LEDR[3:0] = a_led;
   assign LEDR[9:4] = 6'b0;  // Turn off unused LEDs
    
   // Synchronizer registers
   reg [3:0] a_sync1, a_sync2;  // Two flip-flops for synchronization
    
   // Debounce counters - one for each button
   reg [19:0] a_count [3:0];  // 20 bits for counting to 1M
    
   // Current button states
   reg [3:0] a_state;
    
   // Two-stage synchronizer
   always @(posedge CLOCK_50)
	begin
		a_sync1 <= a_in;
      a_sync2 <= a_sync1;
   end
    
   // Debouncing and output logic
   integer i;
    
   always @(posedge CLOCK_50)
	begin
	if (reset)
	begin
		a_out <= 4'b0;
      a_led <= 4'b0;
      a_state <= 4'b0;
            
      for (i = 0; i < 4; i = i + 1)
		begin
			a_count[i] <= 20'd0;
      end
	end
   else
	begin
	// Check each button
	for (i = 0; i < 4; i = i + 1)
	begin
		if (a_sync2[i] != a_state[i])
		begin // Current state != previous state
			if (a_count[i] < DB)
				a_count[i] <= a_count[i] + 1'b1;
			else
			begin // Button pressed for enough time
				a_state[i] <= a_sync2[i];
            a_out[i] <= a_sync2[i];
            a_led[i] <= a_sync2[i];
            a_count[i] <= 20'd0;
			end
		end
      else
			a_count[i] <= 20'd0;  // Reset counter, no change
	end
	end
	end
endmodule

module score_tracker(
    input CLOCK_50,            // System clock
    input reset,               // Reset signal
    input [3:0] key_press,     // Push button inputs
    input perfect_hit,         // Perfect hit signal from game
    output reg [6:0] HEX0,     // 7-segment display outputs
    output reg [6:0] HEX1,
    output reg [6:0] HEX2,
    output reg [6:0] HEX3
);

    // Internal score counter (0-99)
    reg [7:0] score;
    
    // 7-segment display patterns (active low)
    reg [6:0] seg7 [0:9];
    
    initial begin
        seg7[0] = 7'b1000000;  // 0
        seg7[1] = 7'b1111001;  // 1
        seg7[2] = 7'b0100100;  // 2
        seg7[3] = 7'b0110000;  // 3
        seg7[4] = 7'b0011001;  // 4
        seg7[5] = 7'b0010010;  // 5
        seg7[6] = 7'b0000010;  // 6
        seg7[7] = 7'b1111000;  // 7
        seg7[8] = 7'b0000000;  // 8
        seg7[9] = 7'b0010000;  // 9
        score = 8'd0;
    end
    
    // Edge detection for perfect_hit
    reg prev_perfect_hit;
    
    // Score update logic
    always @(posedge CLOCK_50 or posedge reset) begin
        if (reset) begin
            score <= 8'd0;
            prev_perfect_hit <= 0;
        end 
        else begin
            prev_perfect_hit <= perfect_hit;
            
            // Detect rising edge of perfect_hit
            if (perfect_hit && !prev_perfect_hit) begin
                if (score < 8'd99) begin
                    score <= score + 1'd1;
                end
            end
        end
    end

    // Display update logic
    always @(posedge CLOCK_50) begin
        // Update 7-segment displays
        HEX0 <= seg7[score % 10];       // Ones digit
        HEX1 <= seg7[score / 10];       // Tens digit
        HEX2 <= 7'b1111111;            // Turn off HEX2
        HEX3 <= 7'b1111111;            // Turn off HEX3
    end

endmodule

/*
module score_tracker(
    input CLOCK_50,            // System clock
    input reset,               // Reset signal
    input [3:0] key_press,     // Debounced key inputs
	 input perfect_hit,
    output reg [6:0] HEX0,     // 7-segment display outputs
    output reg [6:0] HEX1,
    output reg [6:0] HEX2,
    output reg [6:0] HEX3
);

    // Internal score counter (0-99)
    reg [7:0] score;
	 
    // 7-segment display patterns (active low)
    reg [6:0] seg7 [0:9];
	 
    initial begin
        seg7[0] = 7'b1000000;  // 0
        seg7[1] = 7'b1111001;  // 1
        seg7[2] = 7'b0100100;  // 2
        seg7[3] = 7'b0110000;  // 3
        seg7[4] = 7'b0011001;  // 4
        seg7[5] = 7'b0010010;  // 5
        seg7[6] = 7'b0000010;  // 6
        seg7[7] = 7'b1111000;  // 7
        seg7[8] = 7'b0000000;  // 8
        seg7[9] = 7'b0010000;  // 9
    end
	 
    // Score update logic
    always @(posedge CLOCK_50 or posedge reset) begin
        if (reset) begin
            score <= 8'd0;     // Reset score to 0
        end else if (perfect_hit && score < 8'd99)begin
            score <= score + 1'd1;
        end
    end
    // Display update logic
    always @(posedge CLOCK_50) begin
        // Update 7-segment displays
        HEX0 <= seg7[score % 10];  // Ones digit
        HEX1 <= seg7[score / 10];  // Tens digit
        HEX2 <= 7'b1111111;       // Turn off HEX2
        HEX3 <= 7'b1111111;       // Turn off HEX3
    end
endmodule
*/

/*
module arrow_game(
    input CLOCK_50,
    input reset,
    input [3:0] key_press,
    output [7:0] VGA_R,
    output [7:0] VGA_G,
    output [7:0] VGA_B,
    output VGA_HS, VGA_VS, VGA_BLANK_N, VGA_SYNC_N, VGA_CLK,
    output reg perfect_hit
);

    // Parameters for arrow dimensions and position
    parameter ARROW_WIDTH = 7;    
    parameter ARROW_HEIGHT = 7;   
    parameter SCREEN_WIDTH = 160;
    parameter SCREEN_HEIGHT = 120;
    parameter TARGET_Y = 100;     
    parameter HIT_RANGE = 4;      // Increased hit range for easier scoring
    
    // Arrow state
    reg [7:0] arrow_x;
    reg [6:0] arrow_y;
    reg arrow_active;
    reg [19:0] move_counter;
    
    // X and Y counters for pixel position
    reg [7:0] x_counter;
    reg [6:0] y_counter;
    reg [2:0] pixel_color;
    
    // Movement speed
    parameter MOVE_SPEED = 800000;
    
    // Key press edge detection
    reg prev_key_press;
    reg in_target_zone;
    
    // Initialize
    initial begin
        arrow_x = 80;    
        arrow_y = 0;
        arrow_active = 1;
        perfect_hit = 0;
        move_counter = 0;
        prev_key_press = 0;
        in_target_zone = 0;
    end
    
    // Counter for pixel position
    always @(posedge CLOCK_50 or posedge reset) begin
        if (reset) begin
            x_counter <= 8'd0;
            y_counter <= 7'd0;
        end
        else begin
            if (x_counter == 159) begin
                x_counter <= 0;
                if (y_counter == 119)
                    y_counter <= 0;
                else
                    y_counter <= y_counter + 1;
            end
            else begin
                x_counter <= x_counter + 1;
            end
        end
    end

    // Arrow movement and hit detection logic
    always @(posedge CLOCK_50 or posedge reset) begin
        if (reset) begin
            arrow_y <= 0;
            move_counter <= 0;
            arrow_active <= 1;
            perfect_hit <= 0;
            arrow_x <= 80;
            prev_key_press <= 0;
            in_target_zone <= 0;
        end
        else begin
            perfect_hit <= 0;
            
            // Update target zone status
            in_target_zone <= (arrow_y >= (TARGET_Y - HIT_RANGE) && 
                             arrow_y <= (TARGET_Y + HIT_RANGE));
            
            // Key press edge detection
            prev_key_press <= key_press[3];
            
            // Check for new key press (rising edge) AND in target zone
            if (key_press[3] && !prev_key_press && arrow_active) begin
                if (in_target_zone) begin
                    perfect_hit <= 1;
                    arrow_active <= 0;
                end
            end
            
            // Move arrow
            if (move_counter >= MOVE_SPEED) begin
                move_counter <= 0;
                if (arrow_active) begin
                    if (arrow_y >= SCREEN_HEIGHT) begin
                        arrow_y <= 0;
                        arrow_active <= 1;
                    end
                    else begin
                        arrow_y <= arrow_y + 1;
                    end
                end
                else begin
                    arrow_y <= 0;
                    arrow_active <= 1;
                end
            end
            else begin
                move_counter <= move_counter + 1;
            end
        end
    end
    
    // Color generation logic
    always @(*) begin
        // Default black background
        pixel_color = 3'b000;
        
        // Draw arrow (white) when active
        if (arrow_active && 
            x_counter >= arrow_x && x_counter < (arrow_x + ARROW_WIDTH) &&
            y_counter >= arrow_y && y_counter < (arrow_y + ARROW_HEIGHT)) begin
            
            // Center vertical line (shaft)
            if (x_counter == arrow_x + 3) 
                pixel_color = 3'b111;
            
            // Arrow head (triangle shape)
            else if (y_counter == arrow_y &&                          // Top point
                    x_counter == arrow_x + 3)
                pixel_color = 3'b111;
            else if (y_counter == arrow_y + 1 &&                      // Second row
                    (x_counter >= arrow_x + 2 && x_counter <= arrow_x + 4))
                pixel_color = 3'b111;
            else if (y_counter == arrow_y + 2 &&                      // Third row
                    (x_counter >= arrow_x + 1 && x_counter <= arrow_x + 5))
                pixel_color = 3'b111;
        end
        
        // Draw main target line (bright blue)
        if (y_counter == TARGET_Y) begin
            pixel_color = 3'b011;  // Brighter blue
        end
        
        // Draw target zone borders (dimmer blue)
        if (y_counter == TARGET_Y - HIT_RANGE || y_counter == TARGET_Y + HIT_RANGE) begin
            pixel_color = 3'b001;  // Dim blue
        end

        // Visual feedback when in target zone
        if (arrow_active && in_target_zone) begin
            // Add subtle highlight to target line
            if (y_counter == TARGET_Y && 
                x_counter >= arrow_x - 2 && x_counter <= arrow_x + ARROW_WIDTH + 2) begin
                pixel_color = 3'b111;  // White highlight when arrow is in position
            end
        end
    end
    
    // VGA adapter instantiation
    vga_adapter VGA(
        .resetn(!reset),
        .clock(CLOCK_50),
        .colour(pixel_color),
        .x(x_counter),
        .y(y_counter),
        .plot(1'b1),
        .VGA_R(VGA_R),
        .VGA_G(VGA_G),
        .VGA_B(VGA_B),
        .VGA_HS(VGA_HS),
        .VGA_VS(VGA_VS),
        .VGA_BLANK_N(VGA_BLANK_N),
        .VGA_SYNC_N(VGA_SYNC_N),
        .VGA_CLK(VGA_CLK)
    );
    
    defparam VGA.RESOLUTION = "160x120";
    defparam VGA.MONOCHROME = "FALSE";
    defparam VGA.BITS_PER_COLOUR_CHANNEL = 1;
    defparam VGA.BACKGROUND_IMAGE = "black.mif";

endmodule*/

module arrow_game(
    input CLOCK_50,
    input reset,
    input [3:0] key_press,
    output [7:0] VGA_R,
    output [7:0] VGA_G,
    output [7:0] VGA_B,
    output VGA_HS, VGA_VS, VGA_BLANK_N, VGA_SYNC_N, VGA_CLK,
    output reg perfect_hit
);

    // Parameters for arrow dimensions and position
    parameter ARROW_WIDTH = 7;    
    parameter ARROW_HEIGHT = 7;   
    parameter SCREEN_WIDTH = 160;
    parameter SCREEN_HEIGHT = 120;
    parameter TARGET_Y = 100;     
    parameter HIT_RANGE = 4;      
    
    // Arrow states for each direction
    reg [7:0] arrow_x [3:0];  // Array for 4 arrows' x positions
    reg [6:0] arrow_y [3:0];  // Array for 4 arrows' y positions
    reg [3:0] arrow_active;   // Active state for each arrow
    reg [19:0] move_counter;
    
    // X and Y counters for pixel position
    reg [7:0] x_counter;
    reg [6:0] y_counter;
    reg [2:0] pixel_color;
    
    // Movement speed
    parameter MOVE_SPEED = 800000;
    
    // Key press edge detection
    reg [3:0] prev_key_press;
    reg [3:0] in_target_zone;
    
    // Iterator variable for loops
    integer i;
    
    // Initialize
    initial begin
        // Set initial positions for all arrows
        arrow_x[0] = 40;  // Left arrow
        arrow_x[1] = 80;  // Up arrow
        arrow_x[2] = 120; // Right arrow
        arrow_x[3] = 80;  // Down arrow
		  arrow_y[3] = 20; //y position of down arrow
        
        for (i = 0; i < 4; i = i + 1) begin
            arrow_y[i] = 0;
        end
        
        arrow_active = 4'b1111; // All arrows active
        perfect_hit = 0;
        move_counter = 0;
        prev_key_press = 0;
        in_target_zone = 0;
    end
    
    // Counter for pixel position
    always @(posedge CLOCK_50 or posedge reset) begin
        if (reset) begin
            x_counter <= 8'd0;
            y_counter <= 7'd0;
        end
        else begin
            if (x_counter == 159) begin
                x_counter <= 0;
                if (y_counter == 119)
                    y_counter <= 0;
                else
                    y_counter <= y_counter + 1;
            end
            else begin
                x_counter <= x_counter + 1;
            end
        end
    end

    // Arrow movement and hit detection logic
    always @(posedge CLOCK_50 or posedge reset) begin
        if (reset) begin
            for (i = 0; i < 4; i = i + 1) begin
                arrow_y[i] <= 0;
                arrow_active[i] <= 1;
            end
            arrow_x[0] <= 40;  // Left arrow
            arrow_x[1] <= 80;  // Up arrow
            arrow_x[2] <= 120; // Right arrow
            arrow_x[3] <= 80;  // Down arrow
				arrow_y[3] = 20; //y position of down arrow
            move_counter <= 0;
            perfect_hit <= 0;
            prev_key_press <= 0;
            in_target_zone <= 0;
        end
        else begin
            perfect_hit <= 0;
            
            // Update target zone status for each arrow
            for (i = 0; i < 4; i = i + 1) begin
                in_target_zone[i] <= (arrow_y[i] >= (TARGET_Y - HIT_RANGE) && 
                                    arrow_y[i] <= (TARGET_Y + HIT_RANGE));
            end
            
            // Key press edge detection
            prev_key_press <= key_press;
            
            // Check for new key presses AND in target zone
            for (i = 0; i < 4; i = i + 1) begin
                if (key_press[i] && !prev_key_press[i] && arrow_active[i]) begin
                    if (in_target_zone[i]) begin
                        perfect_hit <= 1;
                        arrow_active[i] <= 0;
                    end
                end
            end
            
            // Move arrows
            if (move_counter >= MOVE_SPEED) begin
                move_counter <= 0;
                for (i = 0; i < 4; i = i + 1) begin
                    if (arrow_active[i]) begin
                        if (arrow_y[i] >= SCREEN_HEIGHT) begin
                            arrow_y[i] <= 0;
                            arrow_active[i] <= 1;
                        end
                        else begin
                            arrow_y[i] <= arrow_y[i] + 1;
                        end
                    end
                    else begin
                        arrow_y[i] <= 0;
                        arrow_active[i] <= 1;
                    end
                end
            end
            else begin
                move_counter <= move_counter + 1;
            end
        end
    end
    
    // Function to determine if current pixel is part of an arrow
    function is_arrow_pixel;
        input [7:0] x, arrow_x;
        input [6:0] y, arrow_y;
        input [1:0] direction; // 0=left, 1=up, 2=right, 3=down
        begin
            case (direction)
                0: begin // Left arrow (90° counterclockwise with tail)
                    is_arrow_pixel = (x >= arrow_x && x < arrow_x + ARROW_HEIGHT &&
                                    y >= arrow_y && y < arrow_y + ARROW_WIDTH &&
                                    ((y == arrow_y + 3) ||  // Horizontal shaft
                                     (x == arrow_x && y == arrow_y + 3) || // Left point
                                     (x == arrow_x + 1 && y >= arrow_y + 2 && y <= arrow_y + 4) ||
                                     (x == arrow_x + 2 && y >= arrow_y + 1 && y <= arrow_y + 5) ||
                                     (x >= arrow_x + 3 && x <= arrow_x + 6 && y == arrow_y + 3))); // Tail extension
                end
                
                1: begin // Up arrow (original)
                    is_arrow_pixel = (x >= arrow_x && x < arrow_x + ARROW_WIDTH &&
                                    y >= arrow_y && y < arrow_y + ARROW_HEIGHT &&
                                    ((x == arrow_x + 3) || // Shaft
                                     (y == arrow_y && x == arrow_x + 3) || // Top point
                                     (y == arrow_y + 1 && x >= arrow_x + 2 && x <= arrow_x + 4) ||
                                     (y == arrow_y + 2 && x >= arrow_x + 1 && x <= arrow_x + 5)));
                end
                
                2: begin // Right arrow (90° clockwise with tail)
                    is_arrow_pixel = (x >= arrow_x && x < arrow_x + ARROW_HEIGHT &&
                                    y >= arrow_y && y < arrow_y + ARROW_WIDTH &&
                                    ((y == arrow_y + 3) ||  // Horizontal shaft
                                     (x == arrow_x + 6 && y == arrow_y + 3) || // Right point
                                     (x == arrow_x + 5 && y >= arrow_y + 2 && y <= arrow_y + 4) ||
                                     (x == arrow_x + 4 && y >= arrow_y + 1 && y <= arrow_y + 5) ||
                                     (x >= arrow_x && x <= arrow_x + 3 && y == arrow_y + 3))); // Tail extension
                end
                
                3: begin // Down arrow
                    is_arrow_pixel = (x >= arrow_x && x < arrow_x + ARROW_WIDTH &&
                                    y >= arrow_y && y < arrow_y + ARROW_HEIGHT &&
                                    ((x == arrow_x + 3) || // Shaft
                                     (y == arrow_y + ARROW_HEIGHT - 1 && x == arrow_x + 3) || // Bottom point
                                     (y == arrow_y + ARROW_HEIGHT - 2 && x >= arrow_x + 2 && x <= arrow_x + 4) ||
                                     (y == arrow_y + ARROW_HEIGHT - 3 && x >= arrow_x + 1 && x <= arrow_x + 5)));
                end
            endcase
        end
    endfunction
    
    // Color generation logic
    always @(*) begin
        // Default black background
        pixel_color = 3'b000;
        
        // Draw active arrows
        for (i = 0; i < 4; i = i + 1) begin
            if (arrow_active[i] && is_arrow_pixel(x_counter, arrow_x[i], y_counter, arrow_y[i], i[1:0])) begin
                pixel_color = 3'b111; // White arrows
            end
        end
        
        // Draw main target line (bright blue)
        if (y_counter == TARGET_Y) begin
            pixel_color = 3'b011;
        end
        
        // Draw target zone borders (dimmer blue)
        if (y_counter == TARGET_Y - HIT_RANGE || y_counter == TARGET_Y + HIT_RANGE) begin
            pixel_color = 3'b001;
        end

        // Visual feedback when in target zone
        for (i = 0; i < 4; i = i + 1) begin
            if (arrow_active[i] && in_target_zone[i]) begin
                if (y_counter == TARGET_Y && 
                    x_counter >= arrow_x[i] - 2 && x_counter <= arrow_x[i] + ARROW_WIDTH + 2) begin
                    pixel_color = 3'b111;
                end
            end
        end
    end
    
    // VGA adapter instantiation
    vga_adapter VGA(
        .resetn(!reset),
        .clock(CLOCK_50),
        .colour(pixel_color),
        .x(x_counter),
        .y(y_counter),
        .plot(1'b1),
        .VGA_R(VGA_R),
        .VGA_G(VGA_G),
        .VGA_B(VGA_B),
        .VGA_HS(VGA_HS),
        .VGA_VS(VGA_VS),
        .VGA_BLANK_N(VGA_BLANK_N),
        .VGA_SYNC_N(VGA_SYNC_N),
        .VGA_CLK(VGA_CLK)
    );
    
    defparam VGA.RESOLUTION = "160x120";
    defparam VGA.MONOCHROME = "FALSE";
    defparam VGA.BITS_PER_COLOUR_CHANNEL = 1;
    defparam VGA.BACKGROUND_IMAGE = "gameplay.mif";

endmodule
